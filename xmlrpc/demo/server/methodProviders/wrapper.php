<?php
/**
 * Defines functions and signatures which can be registered as methods exposed by an XML-RPC Server
 *
 * To use this, use something akin to:
 * $signatures = include('wrapper.php');
 * NB: requires 'functions.php' to be included first
 *
 * Wrap methods of xml-rpc-unaware php classes and xml-rpc-unaware php functions so that they can be used transparently.
 */

use PhpXmlRpc\Response;
use PhpXmlRpc\Value;

// *** functions ***

/**
 * Inner code of the state-number server.
 * Used to test wrapping of PHP functions into xml-rpc methods.
 *
 * @param integer $stateNo the state number
 *
 * @return string the name of the state (or error description)
 *
 * @throws Exception if state is not found
 */
function plain_findstate($stateNo)
{
     if (isset(exampleMethods::$stateNames[$stateNo - 1])) {
        return exampleMethods::$stateNames[$stateNo - 1];
    } else {
        // not, there so complain
        throw new Exception("I don't have a state for the index '" . $stateNo . "'", PhpXmlRpc\PhpXmlRpc::$xmlrpcerruser);
    }
}

$wrapper = new PhpXmlRpc\Wrapper();

$findstate2_sig = $wrapper->wrapPhpFunction('plain_findstate');


// *** objects/classes ***

/**
 * Used to test usage of object methods in dispatch maps and in wrapper code.
 */
class handlersContainer
{
    /**
     * Method used to test logging of php warnings generated by user functions.
     * @param PhpXmlRpc\Request $req
     * @return Response
     */
    public function phpWarningGenerator($req)
    {
        /** @noinspection PhpUndefinedVariableInspection */
        $a = $undefinedVariable; // this triggers a warning in E_ALL mode, since $undefinedVariable is undefined
        return new Response(new Value(1, Value::$xmlrpcBoolean));
    }

    /**
     * Method used to test catching of exceptions in the server.
     * @param PhpXmlRpc\Request $req
     * @throws Exception
     */
    public function exceptionGenerator($req)
    {
        $errNum = 1;
        if ($req->getNumParams()) {
            $p1 = $req->getParam(0);
            if ($p1->kindOf() === 'scalar') {
                $errNum = (int)$p1->scalarVal();
            }
        }
        throw new Exception("it's just a test", $errNum);
    }

    /**
     * Method used to test catching of errors in the server.
     * @param PhpXmlRpc\Request $req
     * @throws Exception
     */
    public function errorGenerator($req)
    {
        throw new Error("it's just a test", 1);
    }

    /**
     * @param string $msg
     */
    public function debugMessageGenerator($msg)
    {
        PhpXmlRpc\Server::xmlrpc_debugmsg($msg);
    }

    /**
     * A PHP version of the state-number server. Send me an integer and i'll sell you a state.
     * Used to test wrapping of PHP methods into xml-rpc methods.
     *
     * @param integer $num
     * @return string
     * @throws Exception
     */
    public static function findState($num)
    {
        // we are lazy ;-)
        return plain_findstate($num);
    }

    /**
     * Returns an instance of stdClass.
     * Used to test wrapping of PHP objects with class preservation
     */
    public function returnObject()
    {
        $obj = new stdClass();
        $obj->hello = 'world';
        return $obj;
    }
}

$findstate3_sig = $wrapper->wrapPhpFunction(array('handlersContainer', 'findState'));

$instance = new handlersContainer();
$findstate4_sig = $wrapper->wrapPhpFunction(array($instance, 'findstate'));

$findstate5_sig = $wrapper->wrapPhpFunction('handlersContainer::findState', '', array('return_source' => true));
eval($findstate5_sig['source']);

$findstate6_sig = $wrapper->wrapPhpFunction('plain_findstate', '', array('return_source' => true));
eval($findstate6_sig['source']);

$findstate7_sig = $wrapper->wrapPhpFunction(array('handlersContainer', 'findState'), '', array('return_source' => true));
eval($findstate7_sig['source']);

$findstate8_sig = $wrapper->wrapPhpFunction(array($instance, 'findstate'), '', array('return_source' => true));
eval($findstate8_sig['source']);

$findstate9_sig = $wrapper->wrapPhpFunction('handlersContainer::findState', '', array('return_source' => true));
eval($findstate9_sig['source']);

$findstate10_sig = array(
    /// @todo add a demo and test with closure usage
    "function" => function ($req) { return exampleMethods::findState($req); },
    "signature" => array(array(Value::$xmlrpcString, Value::$xmlrpcInt)),
    "docstring" => 'When passed an integer between 1 and 51 returns the name of a US state, where the integer is the ' .
        'index of that state name in an alphabetic order.',
);

$findstate11_sig = $wrapper->wrapPhpFunction(function ($stateNo) { return plain_findstate($stateNo); });

/// @todo do we really need a new instance ?
$c = new handlersContainer();

$moreSignatures = $wrapper->wrapPhpClass($c, array('prefix' => 'tests.', 'method_type' => 'all'));

$namespaceSignatures = $wrapper->wrapPhpClass($c, array('prefix' => 'namespacetest.', 'replace_class_name' => true, 'method_filter' => '/^findState$/', 'method_type' => 'static'));

$returnObj_sig =  $wrapper->wrapPhpFunction(array($c, 'returnObject'), '', array('encode_php_objs' => true));

return array_merge(
    array(
        'tests.getStateName.2' => $findstate2_sig,

        'tests.getStateName.3' => $findstate3_sig,
        'tests.getStateName.4' => $findstate4_sig,
        'tests.getStateName.5' => $findstate5_sig,
        'tests.getStateName.6' => $findstate6_sig,
        'tests.getStateName.7' => $findstate7_sig,
        'tests.getStateName.8' => $findstate8_sig,
        'tests.getStateName.9' => $findstate9_sig,
        'tests.getStateName.10' => $findstate10_sig,
        'tests.getStateName.11' => $findstate11_sig,
    ),
    $moreSignatures,
    $namespaceSignatures,
    array(
        'tests.returnPhpObject' => $returnObj_sig,
        // signature omitted on purpose
        "tests.generatePHPWarning" => array(
            "function" => array($instance, "phpWarningGenerator"),
        ),
        // signature omitted on purpose
        "tests.raiseException" => array(
            "function" => array($instance, "exceptionGenerator"),
        ),
        "tests.raiseError" => array(
            "function" => array($instance, "errorGenerator"),
        ),
    )
);
